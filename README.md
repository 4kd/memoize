# Memoize

いい感じにメモ化してくれるライブラリ

## 特徴

- 複数プロセスから同時に呼んでも、キャッシュ処理を行うのは１プロセスだけ
  - 他のプロセスは、キャッシュ処理しているプロセスがキャッシュを完了するまで待つ
- ロック用のプロセスを使わず ETS のみで完結しているので高速

例えば以下のようなコードがあるとする。

```elixir
def f() do
  case :ets.lookup(@tab, @key) do
    [] ->
      result = load_heavy_data_from_database()
      :ets.insert(@tab, {@key, result})
    [{_, result}] ->
      result
  end
end
```

これは排他制御を行わないキャッシュ処理である。
あるプロセスが `load_heavy_data_from_database()` で待っている時に他のプロセスが `f()` 関数を呼び出した場合、そのプロセスも `load_heavy_data_from_database()` で待つことになる。
運が悪い場合、100プロセス、200プロセスが `load_heavy_data_from_database()` を呼ぶことになり、キャッシュしている意味が無くなってしまう。
そのため、複数プロセスが `load_heavy_data_from_database()` を呼ばないように排他制御する必要がある。

Elixir で排他制御するには、一般的にはプロセスを利用する。
しかし排他制御のためにプロセスを利用する場合、以下の問題がある。

- キャッシュ後はロック用プロセスが不要になるが、キャッシュを待っているプロセスに正しくメッセージを返した上で安全に終了するのが難しい
- ユーザがロック用プロセスを用意する場合、ユーザがそれらのプロセスを適切に管理する必要がある
- ロック用プロセスの数によっては、プロセスのメッセージキューがボトルネックになってしまう可能性がある

そのため、このライブラリではロック用プロセスを使わずキャッシュを実現している。
鍵となるのは Erlang/OTP 20 で追加された `:ets.select_replace/2` 関数である。
この関数を使うことで、ETS 上で compare-and-swap ができるようになった。
CAS を使うことで、ロック用プロセスが不要になった。
